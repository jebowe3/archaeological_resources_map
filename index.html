<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Leaflet Splash Layout</title>

    <!-- Leaflet -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <!-- Load jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Load PapaParse -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <!-- Leaflet Marker Cluster -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
    />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
    />
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

    <style>
      :root {
        --bg0: #070a12;
        --bg1: rgba(255, 255, 255, 0.06);
        --bg2: rgba(255, 255, 255, 0.1);
        --stroke: rgba(255, 255, 255, 0.14);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.65);
        --shadow: 0 12px 40px rgba(0, 0, 0, 0.45);
        --radius-xl: 22px;
        --radius-lg: 16px;
        --radius-md: 12px;
        --accent: #7c3aed;
        /* purple */
        --accent2: #22d3ee;
        /* cyan */
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
        color: var(--text);
        background: radial-gradient(
            1200px 700px at 20% 10%,
            rgba(124, 58, 237, 0.25),
            transparent 55%
          ),
          radial-gradient(
            1000px 600px at 80% 30%,
            rgba(34, 211, 238, 0.18),
            transparent 55%
          ),
          linear-gradient(180deg, #050711 0%, #070a12 60%, #060812 100%);
      }

      /* Full-page shell */
      .app {
        height: 100%;
        display: grid;
        grid-template-rows: 10vh 1fr;
        /* header is top 10% */
        gap: 18px;
        padding: 18px;
      }

      /* Header bar */
      .header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 18px;
        border-radius: var(--radius-xl);
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.1),
          rgba(255, 255, 255, 0.04)
        );
        border: 1px solid var(--stroke);
        box-shadow: var(--shadow);
        backdrop-filter: blur(14px);
      }

      .brand {
        display: flex;
        align-items: center;
        gap: 12px;
        min-width: 0;
      }

      .logo {
        width: 38px;
        height: 38px;
        border-radius: 12px;
        background: linear-gradient(135deg, var(--accent), var(--accent2));
        box-shadow: 0 10px 30px rgba(124, 58, 237, 0.25);
        position: relative;
        flex: 0 0 auto;
      }

      .logo:after {
        content: "";
        position: absolute;
        inset: 9px;
        border-radius: 10px;
        background: rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }

      .title-wrap {
        min-width: 0;
      }

      .title {
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.2px;
        margin: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .subtitle {
        margin: 2px 0 0 0;
        font-size: 13px;
        color: var(--muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .header-actions {
        display: flex;
        align-items: center;
        gap: 10px;
        flex: 0 0 auto;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.05);
        color: var(--muted);
        font-size: 12px;
      }

      /* Segmented toggle in header */
      .segmented {
        display: inline-flex;
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.05);
        border-radius: 999px;
        overflow: hidden;
      }

      .seg-btn {
        border: 0;
        background: transparent;
        color: var(--muted);
        padding: 10px 12px;
        cursor: pointer;
        font-size: 12px;
        transition: background 0.15s ease, color 0.15s ease;
      }

      .seg-btn:hover {
        background: rgba(255, 255, 255, 0.08);
        color: var(--text);
      }

      .seg-btn.is-active {
        background: linear-gradient(
          135deg,
          rgba(124, 58, 237, 0.95),
          rgba(34, 211, 238, 0.85)
        );
        color: rgba(255, 255, 255, 0.95);
      }

      /* Two-panel panes */
      .pane {
        display: none;
      }

      .pane.is-active {
        display: block;
      }

      .btn {
        border: 1px solid var(--stroke);
        background: rgba(255, 255, 255, 0.06);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        cursor: pointer;
        transition: transform 0.08s ease, background 0.15s ease,
          border-color 0.15s ease;
      }

      .btn:hover {
        background: rgba(255, 255, 255, 0.1);
        border-color: rgba(255, 255, 255, 0.22);
      }

      .btn:active {
        transform: translateY(1px);
      }

      /* Main split layout */
      .main {
        display: grid;
        grid-template-columns: 25% 75%;
        gap: 18px;
        min-height: 0;
        /* allows children to size properly */
      }

      /* Left form panel */
      .panel {
        border-radius: var(--radius-xl);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.08),
          rgba(255, 255, 255, 0.04)
        );
        border: 1px solid var(--stroke);
        box-shadow: var(--shadow);
        backdrop-filter: blur(14px);
        padding: 16px;
        min-height: 0;
        overflow: auto;
      }

      .panel h2 {
        margin: 0 0 6px 0;
        font-size: 14px;
        letter-spacing: 0.4px;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.78);
      }

      .panel p {
        margin: 0 0 14px 0;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.4;
      }

      .field {
        display: grid;
        gap: 8px;
        margin-bottom: 12px;
      }

      /* instead of label { ... } */
      .panel label {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.75);
      }

      /* instead of input, select, textarea { ... } */
      .panel input,
      .panel select,
      .panel textarea {
        width: 100%;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.2);
        color: var(--text);
        padding: 10px 12px;
        outline: none;
      }

      input:focus,
      select:focus,
      textarea:focus {
        border-color: rgba(124, 58, 237, 0.65);
        box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.18);
      }

      textarea {
        resize: vertical;
        min-height: 88px;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .primary {
        background: linear-gradient(
          135deg,
          rgba(124, 58, 237, 0.95),
          rgba(34, 211, 238, 0.85)
        );
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .actions {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }

      .hint {
        margin-top: 14px;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px dashed rgba(255, 255, 255, 0.18);
        color: rgba(255, 255, 255, 0.7);
        font-size: 12px;
        line-height: 1.4;
        background: rgba(255, 255, 255, 0.03);
      }

      /* Map card */
      .map-card {
        border-radius: var(--radius-xl);
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid var(--stroke);
        box-shadow: var(--shadow);
        overflow: hidden;
        /* keeps map corners rounded */
        min-height: 0;
        position: relative;
      }

      /* Leaflet div must have explicit size */
      #map {
        height: 100%;
        width: 100%;
      }

      .leaflet-control-layers {
        background: rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.18);
        backdrop-filter: blur(10px);
        border-radius: 14px;
        color: rgba(255, 255, 255, 0.88);
      }

      .leaflet-control-layers label {
        color: rgba(255, 255, 255, 0.88);
      }

      .leaflet-control-layers-separator {
        border-top: 1px solid rgba(255, 255, 255, 0.18);
      }

      /* Responsive: stack on narrow screens */
      @media (max-width: 980px) {
        .app {
          grid-template-rows: auto 1fr;
        }

        .main {
          grid-template-columns: 1fr;
        }

        .map-card {
          min-height: 52vh;
        }
      }

      /* Prevent browser focus rectangle around clicked SVG features */
      .leaflet-interactive:focus,
      .leaflet-interactive:focus-visible {
        outline: none !important;
      }

      .leaflet-popup-content {
        margin: 0 !important;
        width: auto !important;
      }
    </style>
  </head>

  <body>
    <div class="app">
      <header class="header">
        <div class="brand">
          <div class="logo" aria-hidden="true"></div>
          <div class="title-wrap">
            <p class="title">Archaeological Resources Map</p>
            <p class="subtitle">
              Crowd-sourced locations in North Carolina
            </p>
          </div>
        </div>

        <div class="header-actions">
          <div class="pill" title="Status">
            <span
              style="
                display: inline-block;
                width: 8px;
                height: 8px;
                border-radius: 999px;
                background: rgba(34, 211, 238, 0.9);
                box-shadow: 0 0 0 4px rgba(34, 211, 238, 0.12);
              "
            ></span>
            Ready
          </div>

          <!-- NEW: panel toggle -->
          <div class="segmented" role="tablist" aria-label="Panel selector">
            <button
              class="seg-btn is-active"
              id="btnPanelInputs"
              type="button"
              role="tab"
              aria-selected="true"
            >
              Inputs
            </button>
            <button
              class="seg-btn"
              id="btnPanelFilters"
              type="button"
              role="tab"
              aria-selected="false"
            >
              Filters
            </button>
          </div>

          <button class="btn" id="btnResetView" type="button">
            Reset View
          </button>
        </div>
      </header>

      <main class="main">
        <aside class="panel">
          <!-- PANE 1: Inputs -->
          <div id="paneInputs" class="pane is-active">
            <h2>Inputs</h2>
            <p>Use this panel to add new markers and information to the map.</p>

            <form id="controls">
              <div class="field">
                <label for="place">Name / Label</label>
                <input
                  id="place"
                  name="place"
                  type="text"
                  placeholder="e.g., 'American Historical Society'"
                />
              </div>

              <div class="row">
                <div class="field">
                  <label for="lat">Latitude</label>
                  <input
                    id="lat"
                    name="lat"
                    type="number"
                    step="any"
                    placeholder="Click map…"
                    readonly
                  />
                </div>
                <div class="field">
                  <label for="lng">Longitude</label>
                  <input
                    id="lng"
                    name="lng"
                    type="number"
                    step="any"
                    placeholder="Click map…"
                    readonly
                  />
                </div>
              </div>

              <div class="field">
                <label for="desc">Description</label>
                <textarea
                  id="desc"
                  name="desc"
                  placeholder="Optional description..."
                ></textarea>
              </div>

              <div class="field">
                <label for="image">Image URL</label>
                <input
                  id="image"
                  name="image"
                  type="url"
                  placeholder="https://example.com/photo.jpg"
                />
                <img
                  id="imagePreview"
                  style="
                    display: none;
                    width: 100%;
                    border-radius: 12px;
                    margin-top: 10px;
                  "
                />
              </div>

              <div class="field">
                <label for="url">URL</label>
                <input
                  id="url"
                  name="url"
                  type="url"
                  placeholder="https://example.com"
                />
              </div>

              <div class="actions">
                <button class="btn primary" type="submit">Submit</button>
                <button class="btn" type="button" id="btnClear">Clear</button>
              </div>

              <div class="hint">
                Tip: Click the map to capture coordinates, then fill out the
                details and hit <b>Submit</b>.
              </div>
            </form>
          </div>

          <!-- PANE 2: Filters -->
          <div id="paneFilters" class="pane">
            <h2>Filters</h2>
            <p>
              Choose a Region <b>or</b> a County (not both). Markers will filter
              to the selected geography and the map will zoom to it.
            </p>

            <div class="field">
              <label for="selRegion">Region</label>
              <select id="selRegion">
                <option value="">Select a Region…</option>
              </select>
            </div>

            <div class="field">
              <label for="selCounty">County</label>
              <select id="selCounty">
                <option value="">Select a County…</option>
              </select>
            </div>

            <div class="actions">
              <button class="btn" type="button" id="btnClearFilters">
                Clear Filter
              </button>
            </div>

            <div class="hint">
              Selecting a Region will disable the County dropdown (and vice
              versa).
            </div>
          </div>
        </aside>
        <section class="map-card">
          <div id="map" role="application" aria-label="Leaflet map"></div>
        </section>
      </main>
    </div>

    <script>
      // Define North Carolina bounds
      const northCarolinaBounds = [
        [33.84, -84.32], // Southwest
        [36.59, -75.46], // Northeast
      ];

      // Set the initial view to the North Carolina bounds above
      const map = L.map("map", {
        zoomControl: true,
        preferCanvas: true,
      }).fitBounds(northCarolinaBounds);

      // Basemap (Carto Voyager)
      L.tileLayer(
        "https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png",
        {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>; <a href="https://github.com/jebowe3">Jay Bowen, GIS Developer, ITRE, NCSU</a>',
          subdomains: "abcd",
          maxZoom: 20,
        }
      ).addTo(map);

      // Popup image load handling
      map.on("popupopen", (ev) => {
        const popup = ev.popup;
        const el = popup.getElement();
        if (!el) return;

        const imgs = el.querySelectorAll("img");
        if (!imgs.length) {
          // Still good to update once in case fonts/layout shift
          setTimeout(() => popup.update(), 0);
          return;
        }

        let pending = 0;

        imgs.forEach((img) => {
          // If already loaded (cached), nothing to wait for
          if (img.complete) return;

          pending++;
          img.addEventListener(
            "load",
            () => {
              pending--;
              if (pending === 0) {
                popup.update(); // re-anchor to marker
                map.panInside(popup.getLatLng(), {
                  padding: [20, 20],
                }); // optional
              }
            },
            {
              once: true,
            }
          );

          img.addEventListener(
            "error",
            () => {
              pending--;
              if (pending === 0) {
                popup.update();
              }
            },
            {
              once: true,
            }
          );
        });

        // If all images were already complete, still update once
        if (pending === 0) setTimeout(() => popup.update(), 0);
      });

      // Layer for user inputs using marker clustering
      const userInputsLayer = L.markerClusterGroup({
        showCoverageOnHover: false,
        spiderfyOnMaxZoom: true,
        disableClusteringAtZoom: 16, // tweak as desired
        maxClusterRadius: 20, // how close before clustering (px)
      }).addTo(map);

      // Google Sheet API URL
      const SHEET_API_URL =
        "https://script.google.com/macros/s/AKfycbyxlBAAus8aMU8kU6L8db_WmBb73-CLaaC1miDCisikoK7kAXekS93gaN08Eoyg5mK4/exec";
      // Published CSV URL for "user_inputs" sheet
      const PUBLISHED_CSV_URL =
        "https://docs.google.com/spreadsheets/d/e/2PACX-1vTA-4Z6e7vHpirRLmqjjdttCmuoqPrq2oFFOzM05_EHhGJpGEY8opCEC6Tt0BfbIp8qTi9c5O0PlZyc/pub?gid=0&single=true&output=csv";

      // Image proxying function (using weserv.nl) to reduce image size and improve loading
      function proxiedThumb(url, w = 480) {
        const u = (url || "").trim();
        if (!u) return "";

        // weserv expects the URL without protocol or with encoded; this works well for most https URLs.
        return `https://images.weserv.nl/?url=${encodeURIComponent(
          u
        )}&w=${w}&fit=inside&we`;
      }

      // Marker loading logic
      function escapeHtml(str) {
        return String(str || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      // --- incremental marker cache ---
      const markerIndex = new Map(); // id -> { marker, hash }

      // State for refresh logic
      let lastValidRowCount = 0;
      let refreshRetryTimer = null;
      let loadRun = 0; // prevents out-of-order refreshes from clobbering each other

      // --- Geography layers + features (GLOBAL refs) ---
      let countyBorders = null;
      let regionBorders = null;

      let countyFeatures = []; // array of GeoJSON features
      let regionFeatures = []; // array of GeoJSON features

      let activeGeoFeature = null; // currently selected feature (region or county)
      let activeGeoLayer = null; // the Leaflet layer for the selected feature (for highlight)
      let activeGeoType = null; // "region" | "county" | null

      function buildPopup(row) {
        const name = row.name || "";
        const desc = row.description || "";
        const img = row.image || "";
        const url = row.url || "";

        let popup = `<div style="display:inline-block;padding:12px 10px;">`;

        if (name)
          popup += `<div style="font-weight:700;margin-bottom:4px;">${escapeHtml(
            name
          )}</div>`;
        if (desc)
          popup += `<div style="opacity:.85;margin-bottom:8px;">${escapeHtml(
            desc
          )}</div>`;
        if (url)
          popup += `<div style="margin-bottom:8px;">
        <a href="${escapeHtml(
          url
        )}" target="_blank" rel="noopener noreferrer">Open link</a>
      </div>`;
        if (img)
          popup += `
        <div style="width:240px;aspect-ratio:3/2;overflow:hidden;border-radius:12px;">
          <img src="${escapeHtml(proxiedThumb(img, 480))}"
              loading="lazy" decoding="async"
              style="width:100%;height:100%;object-fit:cover;display:block;" />
        </div>`;

        popup += `</div>`;
        return popup;
      }

      function rowHash(row) {
        return JSON.stringify({
          name: row.name || "",
          description: row.description || "",
          image: row.image || "",
          url: row.url || "",
          latitude: Number(row.latitude),
          longitude: Number(row.longitude),
        });
      }

      async function loadUserInputsFromSheet({ cacheBust = true } = {}) {
        const myRun = ++loadRun;

        const url = cacheBust
          ? `${PUBLISHED_CSV_URL}&ts=${Date.now()}`
          : PUBLISHED_CSV_URL;

        try {
          // Fetch the CSV
          const res = await fetch(url, {
            cache: "no-store",
            credentials: "omit", // <-- KEY: don’t send Google cookies
            redirect: "follow",
          });

          if (!res.ok) throw new Error(`CSV fetch failed: HTTP ${res.status}`);

          const csvText = await res.text();

          const head = csvText.slice(0, 200).toLowerCase();

          // If Google returns an HTML interstitial, don’t apply it.
          if (
            head.includes("<!doctype html") ||
            head.includes("<html") ||
            head.includes("accounts.google.com")
          ) {
            console.warn(
              "Non-CSV response from Google (HTML interstitial). Retrying…",
              csvText.slice(0, 200)
            );

            // Retry once quickly with a fresh cache-bust
            await new Promise((r) => setTimeout(r, 400));
            return loadUserInputsFromSheet({ cacheBust: true });
          }

          const results = Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true,
          });

          // If another refresh started after us, abort applying this one
          if (myRun !== loadRun) return { ok: false, skipped: true };

          // If Papa reports parse errors, treat as partial/bad load
          if (results.errors && results.errors.length) {
            console.warn("CSV parse errors:", results.errors);
            return { ok: false, partial: true };
          }

          const data = Array.isArray(results.data) ? results.data : [];

          // Build set of valid rows (has id + valid coords)
          const seen = new Set();
          let validRows = 0;

          for (const row of data) {
            const id = String(row.id || "").trim();
            if (!id) continue;

            const lat = Number(row.latitude);
            const lng = Number(row.longitude);
            if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;

            validRows++;
            seen.add(id);

            const h = rowHash(row);
            const existing = markerIndex.get(id);

            if (!existing) {
              const m = L.marker([lat, lng]).addTo(userInputsLayer);
              m.bindPopup(buildPopup(row), {
                maxWidth: 1000,
                minWidth: 0,
                autoPan: true,
                autoPanPadding: [20, 20],
              });
              markerIndex.set(id, { marker: m, hash: h });
            } else if (existing.hash !== h) {
              existing.marker.setLatLng([lat, lng]);
              existing.marker.setPopupContent(buildPopup(row));
              existing.hash = h;
            }
          }

          // ----- IMPORTANT PART -----
          // Only delete if this load looks "complete enough"
          // If validRows dropped compared to last successful load, skip deletions and retry.
          const looksPartial =
            lastValidRowCount > 0 && validRows < lastValidRowCount;

          if (!looksPartial) {
            for (const [id, entry] of markerIndex) {
              // Don't delete optimistic tmp markers here
              if (String(id).startsWith("tmp_")) continue;

              if (!seen.has(id)) {
                userInputsLayer.removeLayer(entry.marker);
                markerIndex.delete(id);
              }
            }
            lastValidRowCount = validRows;
          } else {
            console.warn(
              `Partial CSV read suspected: validRows=${validRows} < lastValidRowCount=${lastValidRowCount}. Skipping deletions and retrying...`
            );

            // Schedule a quick retry (debounced)
            if (refreshRetryTimer) clearTimeout(refreshRetryTimer);
            refreshRetryTimer = setTimeout(() => {
              loadUserInputsFromSheet({ cacheBust: true }).catch(console.warn);
            }, 500);
          }

          return { ok: true, validRows, looksPartial };
        } catch (err) {
          console.error("Load points failed:", err);

          // On failure, DO NOT delete anything. Just keep what you have.
          return { ok: false, error: err };
        }
      }

      async function ensureLatestPointVisible(newId, tries = 10) {
        for (let i = 0; i < tries; i++) {
          await loadUserInputsFromSheet({
            cacheBust: true,
          });

          if (newId && markerIndex.has(String(newId))) return true;

          await new Promise((r) => setTimeout(r, 200 * (i + 1)));
        }
        return false;
      }

      const imageInput = document.getElementById("image");
      const imagePreview = document.getElementById("imagePreview");

      imageInput.addEventListener("input", () => {
        const u = (imageInput.value || "").trim();
        if (!u) {
          imagePreview.style.display = "none";
          imagePreview.src = "";
          return;
        }
        imagePreview.src = u;
        imagePreview.style.display = "block";
      });

      // --- Click on map to add latitude and longitude ---
      function setLatLngFields(latlng) {
        document.getElementById("lat").value = latlng.lat.toFixed(6);
        document.getElementById("lng").value = latlng.lng.toFixed(6);
      }

      // Initial load of user inputs
      loadUserInputsFromSheet({ cacheBust: true });

      // Click marker for user input preview
      let clickMarker = null;

      // Map click behavior
      map.on("click", (e) => {
        // Set lat/lng fields
        setLatLngFields(e.latlng);
        // Add or move click marker
        if (clickMarker) map.removeLayer(clickMarker);
        clickMarker = L.marker(e.latlng).addTo(map);
      });

      function resetView() {
        map.fitBounds(northCarolinaBounds, {
          animate: true,
        });
      }

      // --- Optimistic marker addition ---
      function addOptimisticMarker(payload) {
        const tmpId = "tmp_" + Date.now();

        const optimisticRow = {
          ...payload,
          id: tmpId,
        };

        // (optional) don’t insert duplicates if user double-clicks fast
        if (markerIndex.has(tmpId)) return tmpId;

        const m = L.marker([payload.latitude, payload.longitude]).addTo(
          userInputsLayer
        );
        m.bindPopup(buildPopup(optimisticRow), {
          maxWidth: 1000,
          minWidth: 0,
          autoPan: true,
          autoPanPadding: [20, 20],
        });

        markerIndex.set(tmpId, {
          marker: m,
          hash: rowHash(optimisticRow),
        });

        // optional: show instantly
        // m.openPopup();

        return tmpId;
      }

      // --- Header button behaviors ---
      document
        .getElementById("btnResetView")
        .addEventListener("click", resetView);
      document
        .getElementById("btnPanelInputs")
        .addEventListener("click", () => setPane("inputs"));
      document
        .getElementById("btnPanelFilters")
        .addEventListener("click", () => setPane("filters"));

      // --- Form behavior ---
      const form = document.getElementById("controls");
      form.addEventListener("submit", async (e) => {
        e.preventDefault();

        const submitBtn = form.querySelector('button[type="submit"]');
        if (submitBtn) submitBtn.disabled = true;

        const payload = {
          name: (document.getElementById("place").value || "").trim(),
          description: (document.getElementById("desc").value || "").trim(),
          image: (document.getElementById("image").value || "").trim(),
          url: (document.getElementById("url").value || "").trim(),
          latitude: parseFloat(document.getElementById("lat").value),
          longitude: parseFloat(document.getElementById("lng").value),
        };

        if (
          !Number.isFinite(payload.latitude) ||
          !Number.isFinite(payload.longitude)
        ) {
          alert("Click on the map to set Latitude/Longitude first.");
          if (submitBtn) submitBtn.disabled = false;
          return;
        }

        try {
          submitBtn.textContent = "Submitting…";

          // 1) POST (fire-and-forget; avoid CORS by using no-cors)
          await fetch(`${SHEET_API_URL}?ts=${Date.now()}`, {
            method: "POST",
            mode: "no-cors",
            headers: { "Content-Type": "text/plain;charset=utf-8" },
            body: JSON.stringify(payload),
          });

          // 2) optimistic marker immediately (uses a tmp id)
          addOptimisticMarker(payload);

          // 3) reconcile by reloading CSV (cache-bust so you see the new row sooner)
          loadUserInputsFromSheet({ cacheBust: true }).catch(console.warn);

          // 4) Continue with your existing UX (alert + reset)
          alert("Submitted!");
          form.reset();
          document.getElementById("lat").value = "";
          document.getElementById("lng").value = "";

          if (clickMarker) {
            map.removeLayer(clickMarker);
            clickMarker = null;
          }

          imagePreview.style.display = "none";
          imagePreview.src = "";
        } catch (err) {
          console.error("Submit failed:", err);
          alert("Save failed: " + err.message);
        } finally {
          if (submitBtn) submitBtn.disabled = false;
          submitBtn.textContent = "Submit";
        }
      });

      // Clear button behavior
      document.getElementById("btnClear").addEventListener("click", () => {
        form.reset();
        document.getElementById("lat").value = "";
        document.getElementById("lng").value = "";

        if (clickMarker) {
          map.removeLayer(clickMarker);
          clickMarker = null;
        }

        imagePreview.style.display = "none";
        imagePreview.src = "";
      });

      // Ensure the map sizes correctly if fonts/layout cause late reflow
      window.addEventListener("load", () => {
        setTimeout(() => {
          map.invalidateSize();
        }, 0);
      });

      window.addEventListener("resize", () => map.invalidateSize());

      function setPane(which) {
        const paneInputs = document.getElementById("paneInputs");
        const paneFilters = document.getElementById("paneFilters");
        const btnInputs = document.getElementById("btnPanelInputs");
        const btnFilters = document.getElementById("btnPanelFilters");

        const showInputs = which === "inputs";

        paneInputs.classList.toggle("is-active", showInputs);
        paneFilters.classList.toggle("is-active", !showInputs);

        btnInputs.classList.toggle("is-active", showInputs);
        btnFilters.classList.toggle("is-active", !showInputs);

        btnInputs.setAttribute("aria-selected", showInputs ? "true" : "false");
        btnFilters.setAttribute(
          "aria-selected",
          !showInputs ? "true" : "false"
        );
      }

      // --- Point in Polygon helpers (no extra libraries) ---
      function pointInRing(pt, ring) {
        // pt: [lng, lat], ring: array of [lng, lat]
        let inside = false;
        const x = pt[0],
          y = pt[1];

        for (let i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          const xi = ring[i][0],
            yi = ring[i][1];
          const xj = ring[j][0],
            yj = ring[j][1];

          const intersect =
            yi > y !== yj > y &&
            x < ((xj - xi) * (y - yi)) / (yj - yi + 0.0) + xi;

          if (intersect) inside = !inside;
        }
        return inside;
      }

      function pointInPolygonLngLat(pt, geom) {
        // pt: [lng, lat]
        // geom: GeoJSON geometry Polygon or MultiPolygon
        if (!geom) return false;

        if (geom.type === "Polygon") {
          // geom.coordinates: [ring1, ring2...]
          // ring1 outer, others holes
          const rings = geom.coordinates;
          if (!rings.length) return false;

          if (!pointInRing(pt, rings[0])) return false; // must be in outer ring
          for (let k = 1; k < rings.length; k++) {
            if (pointInRing(pt, rings[k])) return false; // inside a hole => out
          }
          return true;
        }

        if (geom.type === "MultiPolygon") {
          // geom.coordinates: array of polygons
          for (const poly of geom.coordinates) {
            const rings = poly;
            if (!rings.length) continue;

            if (!pointInRing(pt, rings[0])) continue;
            let inHole = false;
            for (let k = 1; k < rings.length; k++) {
              if (pointInRing(pt, rings[k])) {
                inHole = true;
                break;
              }
            }
            if (!inHole) return true;
          }
          return false;
        }

        return false;
      }

      function applyGeoFilter(feature, whichLayer) {
        const prevLayer = activeGeoLayer;
        const prevType = activeGeoType;

        // feature can be null => clear filter
        activeGeoFeature = feature || null;

        // Ensure the correct boundary layer is ON and the other is OFF
        if (regionBorders && countyBorders) {
          if (whichLayer === "region") {
            if (!map.hasLayer(regionBorders)) map.addLayer(regionBorders);
            if (map.hasLayer(countyBorders)) map.removeLayer(countyBorders);
          } else if (whichLayer === "county") {
            if (!map.hasLayer(countyBorders)) map.addLayer(countyBorders);
            if (map.hasLayer(regionBorders)) map.removeLayer(regionBorders);
          } else {
            // clearing
            // leave whatever you prefer on; I'm turning regions on as default
            if (!map.hasLayer(regionBorders)) map.addLayer(regionBorders);
            if (map.hasLayer(countyBorders)) map.removeLayer(countyBorders);
          }
        }

        // Remove previous highlight (based on what was previously selected)
        if (prevLayer) {
          try {
            if (prevType === "region" && regionBorders)
              regionBorders.resetStyle(prevLayer);
            if (prevType === "county" && countyBorders)
              countyBorders.resetStyle(prevLayer);
          } catch {}
        }
        activeGeoLayer = null;
        activeGeoType = null;

        // Highlight the selected polygon and zoom to it
        if (feature) {
          const parent =
            whichLayer === "region" ? regionBorders : countyBorders;
          if (parent) {
            parent.eachLayer((lyr) => {
              if (lyr.feature === feature) {
                activeGeoLayer = lyr;
                activeGeoType = whichLayer; // "region" or "county"
                lyr.setStyle({ weight: 3, opacity: 1, fillOpacity: 0.0 });
                map.fitBounds(lyr.getBounds(), { padding: [20, 20] });
              }
            });
          }
        } else {
          // cleared filter => reset view if you want
          map.fitBounds(northCarolinaBounds, { animate: true });
        }

        // Filter markers by geometry
        // IMPORTANT: markerIndex entries must include marker + lat/lng
        for (const [id, entry] of markerIndex) {
          const m = entry.marker;
          if (!m) continue;

          // keep tmp optimistic markers visible unless you want them filtered too
          // if (String(id).startsWith("tmp_")) continue;

          const ll = m.getLatLng();
          const pt = [ll.lng, ll.lat];

          const keep = !feature
            ? true
            : pointInPolygonLngLat(pt, feature.geometry);

          if (keep) {
            if (!userInputsLayer.hasLayer(m)) userInputsLayer.addLayer(m);
          } else {
            if (userInputsLayer.hasLayer(m)) userInputsLayer.removeLayer(m);
          }
        }
      }

      function fillSelect(selectEl, values, placeholder) {
        selectEl.innerHTML = "";
        const opt0 = document.createElement("option");
        opt0.value = "";
        opt0.textContent = placeholder;
        selectEl.appendChild(opt0);

        for (const v of values) {
          const opt = document.createElement("option");
          opt.value = v;
          opt.textContent = v;
          selectEl.appendChild(opt);
        }
      }

      // Load nc_counties.geojson data with jQuery and add to map
      $.when(
        $.getJSON("layers/nc_counties.geojson"),
        $.getJSON("layers/nc_regions.geojson")
      ).done(function (counties, regions) {
        const countiesGeo = counties[0];
        const regionsGeo = regions[0];

        // store features for dropdowns
        countyFeatures = (countiesGeo.features || []).slice();
        regionFeatures = (regionsGeo.features || []).slice();

        // Build county borders layer (but DO NOT add yet; default is regions)
        countyBorders = L.geoJSON(countiesGeo, {
          style: function (feature) {
            return {
              color: "#6fa8dc",
              weight: 1,
              opacity: 0.5,
              fillOpacity: 0.0,
            };
          },
          onEachFeature: function (feature, layer) {
            layer.on("mouseover", function () {
              this.setStyle({
                color: "#6fa8dc",
                weight: 2,
                opacity: 1,
                fillOpacity: 0.0,
              });
              this.bindTooltip(feature.properties.NAME_LOCAS + " County", {
                permanent: false,
                sticky: false,
                direction: "right",
                className: "county-tooltip",
              }).openTooltip();
            });

            layer.on("mouseout", function () {
              countyBorders.resetStyle(this);
              this.closeTooltip();
            });

            // click to select filter
            layer.on("click", function () {
              const name = feature.properties.NAME_LOCAS || "";
              const selCounty = document.getElementById("selCounty");
              const selRegion = document.getElementById("selRegion");

              selCounty.value = name;
              selRegion.value = "";
              selRegion.disabled = true;
              selCounty.disabled = false;

              applyGeoFilter(feature, "county");
              setPane("filters");
            });
          },
        });

        // Build region borders layer (default ON)
        regionBorders = L.geoJSON(regionsGeo, {
          style: function () {
            return {
              color: "#000000",
              weight: 1,
              opacity: 0.5,
              fillOpacity: 0.0,
            };
          },
          onEachFeature: function (feature, layer) {
            layer.on("mouseover", function () {
              this.setStyle({
                color: "#000000",
                weight: 2,
                opacity: 1,
                fillOpacity: 0.0,
              });
              this.bindTooltip(feature.properties.REGION, {
                permanent: false,
                sticky: false,
                direction: "right",
                className: "region-tooltip",
              }).openTooltip();
            });

            layer.on("mouseout", function () {
              regionBorders.resetStyle(this);
              this.closeTooltip();
            });

            // click to select filter
            layer.on("click", function () {
              const name = feature.properties.REGION || "";
              const selCounty = document.getElementById("selCounty");
              const selRegion = document.getElementById("selRegion");

              selRegion.value = name;
              selCounty.value = "";
              selCounty.disabled = true;
              selRegion.disabled = false;

              applyGeoFilter(feature, "region");
              setPane("filters");
            });
          },
        }).addTo(map);

        // Layer control
        const layers = {
          Regions: regionBorders,
          Counties: countyBorders,
        };
        const overlays = {
          "User Inputs": userInputsLayer,
        };
        L.control
          .layers(layers, overlays, {
            collapsed: false,
            position: "topright",
          })
          .addTo(map);

        // Populate dropdowns
        const regionNames = regionFeatures
          .map((f) => String(f.properties?.REGION || "").trim())
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b));

        const countyNames = countyFeatures
          .map((f) => String(f.properties?.NAME_LOCAS || "").trim())
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b));

        const selRegion = document.getElementById("selRegion");
        const selCounty = document.getElementById("selCounty");

        fillSelect(selRegion, regionNames, "Select a Region…");
        fillSelect(selCounty, countyNames, "Select a County…");

        // Dropdown behavior (mutual exclusion + filter)
        selRegion.addEventListener("change", () => {
          const v = selRegion.value;
          if (!v) {
            selCounty.disabled = false;
            applyGeoFilter(null, "clear");
            return;
          }

          selCounty.value = "";
          selCounty.disabled = true;

          const feature = regionFeatures.find(
            (f) => String(f.properties?.REGION || "").trim() === v
          );
          if (feature) applyGeoFilter(feature, "region");
        });

        selCounty.addEventListener("change", () => {
          const v = selCounty.value;
          if (!v) {
            selRegion.disabled = false;
            applyGeoFilter(null, "clear");
            return;
          }

          selRegion.value = "";
          selRegion.disabled = true;

          const feature = countyFeatures.find(
            (f) => String(f.properties?.NAME_LOCAS || "").trim() === v
          );
          if (feature) applyGeoFilter(feature, "county");
        });

        // Clear button
        document
          .getElementById("btnClearFilters")
          .addEventListener("click", () => {
            selRegion.value = "";
            selCounty.value = "";
            selRegion.disabled = false;
            selCounty.disabled = false;

            // de-highlight whatever was selected (region or county)
            if (activeGeoLayer && activeGeoType) {
              try {
                if (activeGeoType === "region" && regionBorders)
                  regionBorders.resetStyle(activeGeoLayer);
                if (activeGeoType === "county" && countyBorders)
                  countyBorders.resetStyle(activeGeoLayer);
              } catch {}
            }
            activeGeoLayer = null;
            activeGeoType = null;
            activeGeoFeature = null;

            applyGeoFilter(null, "clear");
          });
      });
    </script>
  </body>
</html>
